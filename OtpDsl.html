<!DOCTYPE html>
<html>
  <head>
    <title>OtpDsl</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <div class="breadcrumbs">otp_dsl v0.0.1 &rarr; <a href="overview.html">Overview</a> &rarr; <a href="OtpDsl.html">OtpDsl</a></div>

      <h1>
        OtpDsl
        
      </h1>

      

      <ul class="summary_links">
        
        
        
        
        
        
      </ul>

      
        <div id="moduledoc" class="docstring">
          <h1>OtpDsl</h1>

<p>A set of simple Elixir DSLs that wrap the common uses of OTP
servers. For example, here&#39;s the code for a <code>:gen_server</code> that exports
a function <code>factorial!</code>. When called, the actual factorial code is
executed in its own process.</p>

<pre><code class="elixir">defmodule FactorialServer do
  use OtpDsl.Genserver

  defcall factorial!(n) do
    reply(Enum.reduce(1..n, 1, &amp;(&amp;1*&amp;2)))
  end
end
</code></pre>

<p>You could start this from a supervisor, or manually with
<code>FactorialServer.start_link</code>. You can then call the function 
in the server process using</p>

<pre><code class="elixir">FactorialServer.factorial!(20)
</code></pre>

<p>Similarly, here&#39;s a different DSL that simplifies the creation of
<code>:gen_fsm</code> state machines.</p>

<pre><code class="elixir">defmodule Listen.NewFSM do

  use OtpDsl.Genfsm,  register: {:local, :listen_fsm},
                      initial_state: :start,
                      init_params: []

  @timeout 3*1000

  defrecord CallInfo, from: &quot;&quot;, to: &quot;&quot;, suspicious_segments: 0

  ####################
  #
  # Events → our external API

  events do
    call_initiated(from, to)
    suspicious_phrase_heard
    hang_up
  end

  ####################
  #
  # States → transitions we implement

  in_state(:start) do
    { :call_initiated, from, to } -&gt;
      IO.puts &quot;Initiating a call from #{from} to #{to}&quot;
      next_state(:listening, CallInfo.new(from: from, to: to))
  end

  in_state(:listening) do
    { :hang_up } -&gt;
      debug(&quot;Hangup&quot;, context)
      next_state(:start, nil)

    { :suspicious_phrase_heard } -&gt;
      debug(&quot;Heard something suspicious&quot;, context)
      next_state(:transcribing, context.update_suspicious_segments(&amp;1+1), @timeout)
  end

  in_state(:transcribing) do
    { :hang_up } -&gt;
      debug(&quot;Report on call&quot;, context)
      next_state(:start, CallData.new)

    { :timeout } -&gt;
      next_state(:listening, context)
  end

  # Helpers

  defp debug(msg, CallInfo[from: from, to: to, suspicious_segments: suspicious_segments]) do
    IO.puts(&quot;Call from #{from} to #{to}: #{msg}&quot;)
    if suspicious_segments &gt; 0 do
      IO.puts(&quot;    (suspicious_segments: #{suspicious_segments})&quot;)
    end
  end
end
</code></pre>

<p>The intent behind these DSLs it to remove the boilerplate in server
code. While Erlang has Emacs macros that generate it, Elixir has
built-in macros that make it redundant.</p>

<p>Here&#39;s more in-depth documentation for each DSL</p>

<h2>OtpDsl.Genserver</h2>

<p>A simple DSL wrapper for GenServer modules. It reduces duplication by
exploiting the fact that a GenServer module typically has an API function
that calls a corresponding handle_call function that runs on the server
process. We wrap those two functions into one macro. For example, the following
module is a GenServer with a single API, <code>factorial</code>.</p>

<pre><code>defmodule FactorialServer do
  use OtpDsl.Genserver

  defcall factorial!(n) do
    reply(Enum.reduce(1..n, 1, &amp;(&amp;1*&amp;2)))
  end
end
</code></pre>

<p>You could start this from a supervisor, or manually with
<code>FactorialServer.start_link</code>. You can then call the function 
in the server process using </p>

<pre><code>FactorialServer.factorial!(10)
</code></pre>

<p>The <code>use</code> function takes the following options:</p>

<p><code>register</code>
  The specification of the name under which to register the server. For
  example, if you wanted to register globally as <code>:fred</code>, do</p>

<pre><code>  use OtpDsl.Genserver, register: { :global, :fred }
</code></pre>

<p>The option defaults to <code>{ :local, my_name }</code>, where <code>my_name</code> is
  an atom derived from the module name.</p>

<p><code>initial_state</code> 
  A value representing an initial state for tbe server. Defaults to
  <code>nil</code>.</p>

<h3>Example</h3>

<p>Here&#39;s a server that implements a simple key/value store:</p>

<pre><code>defmodule KvServer do
  use OtpDsl.Genserver, initial_state: HashDict.new

  defcall put(key, value), kv_store do
    reply(value, Dict.put(kv_store, key, value))
  end

  defcall get(key), kv_store do
    reply(Dict.get(kv_store, key))
  end
end
</code></pre>

<p>Note how both functions specify that the state should be stored 
in the variable <code>kv_store</code>. The first returns an updated state as the second
argument to reply, and the second leaves the state unchanged.</p>

<h2>OtpDsl.Gemfsm</h2>

<p>A DSL wrapper for Elixir&#39;s GenFSM.Behaviour. For example:</p>

<pre><code class="elixir">defmodule Listen.NewFSM do

  use OtpDsl.Genfsm,  register: {:local, :listen_fsm},
                      initial_state: :start,
                      init_params: []

  @timeout 3*1000

  defrecord CallInfo, from: &quot;&quot;, to: &quot;&quot;, suspicious_segments: 0

  ####################
  #
  # Events → our external API

  events do
    call_initiated(from, to)
    suspicious_phrase_heard
    hang_up
  end

  ####################
  #
  # States → transitions we implement

  in_state(:start) do
    { :call_initiated, from, to } -&gt;
      IO.puts &quot;Initiating a call from #{from} to #{to}&quot;
      next_state(:listening, CallInfo.new(from: from, to: to))
  end

  in_state(:listening) do
    { :hang_up } -&gt;
      debug(&quot;Hangup&quot;, context)
      next_state(:start, nil)

    { :suspicious_phrase_heard } -&gt;
      debug(&quot;Heard something suspicious&quot;, context)
      next_state(:transcribing, context.update_suspicious_segments(&amp;1+1), @timeout)
  end

  in_state(:transcribing) do
    { :hang_up } -&gt;
      debug(&quot;Report on call&quot;, context)
      next_state(:start, CallData.new)

    { :timeout } -&gt;
      next_state(:listening, context)
  end

  # Helpers

  defp debug(msg, CallInfo[from: from, to: to, suspicious_segments: suspicious_segments]) do
    IO.puts(&quot;Call from #{from} to #{to}: #{msg}&quot;)
    if suspicious_segments &gt; 0 do
      IO.puts(&quot;    (suspicious_segments: #{suspicious_segments})&quot;)
    end
  end
end
</code></pre>

<p>There are three sections in this code</p>

<ol>
<li>The <code>use</code> stanza.</li>
<li>The <code>event list</code></li>
<li>The <code>state definitions</code></li>
</ol>

<h3><code>context</code> vs. <code>state</code></h3>

<p>In an Erlang server, state is passed between callbacks. However, it gets confusing talking 
about this server state when we also have the concept of state machine states. So, in this
module, we use the convention that the server state is called the <code>context</code>.</p>

<h3>The <code>use</code> stanza</h3>

<p>As well as including the OptDel.Genfsm behaviour in your module, the <code>use</code>
call lets you set various options:</p>

<table><thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>register</td>
<td>{:local, :fsm }</td>
<td>The first argument to <code>start_link</code>, used to register a name for this module</td>
</tr>
<tr>
<td>initial_state</td>
<td>:state</td>
<td>The name of the initial state of the FSM</td>
</tr>
<tr>
<td>context</td>
<td>[]</td>
<td>The initial context</td>
</tr>
</tbody></table>

<h3>The Event List</h3>

<p>In GenFSM, events are triggered by calls to public functions. Each function then calls <code>send_event</code>
to cause the appropriate callback to be invoked.</p>

<p>This code is pretty boilerplate, so we abstract it into an <code>events</code> stanza:</p>

<pre><code class="elixir">events do
  call_initiated(from, to)
 suspicious_phrase_heard
  hang_up
end
</code></pre>

<p>This block simply creates the following functions:</p>

<pre><code class="elixir">def call_initiated(from, to) do
  :gen_fsm.send_event(«servername», :call_initiated, from, to)
end
def suspicious_phrase_heard do
  :gen_fsm.send_event(«servername», :suspicious_phrase_heard)
end
def hang_up do
  :gen_fsm.send_event(«servername», hang_up)
end
</code></pre>

<p>You&#39;re free to write these functions by hand, too.</p>

<h3>The States</h3>

<p>We represent each state using <code>in_state(«name»)</code>. Within the block, separate clauses
match each incoming event (with optional parameters). The code corresponding with the match
will end with a call to <code>next_state</code>, which takes the new state name, the new context, and an optional timeout (in mS).</p>

<pre><code class="elixir">in_state(:listening) do
  { :hang_up } -&gt;
    debug(&quot;Hangup&quot;, context)
    next_state(:start, nil)

  { :suspicious_phrase_heard } -&gt;
    debug(&quot;Heard something suspicious&quot;, context)
    next_state(:transcribing, context.update_suspicious_segments(&amp;1+1), @timeout)
end
</code></pre>

<p>So, if we&#39;re in state <code>listening</code> and we get a <code>hang_up</code> event, we
call <code>debug</code> to print a message, and then transition to the state
state, with no context. If instead we get a
<code>suspicious_phrase_heard</code> event, we transition to the <code>transcribing</code>
state. We pass an updated context where we increment the number of
suspicious segments, and we set a timeout.</p>

<p>If a timeout fires, it generates a <code>timeout</code> event in the next state
(there&#39;s an example in the <code>transcribing</code> state of the sample app)</p>

<h2>Add to your Project</h2>

<p>Add the following to your list of dependencies in <code>mix.exs</code>:</p>

<pre><code class="elixir">{ :otp_dsl, github: &quot;pragdave/otp_dsl }
</code></pre>

<h2>Copyright</h2>

<p>Copyright © 2013 Dave Thomas, The Pragmatic Programmers</p>

<p>Licensed for use under the same terms as Elixir</p>

        </div>
      

      

      

      

      

      

      

      
    </div>
  </body>
</html>
